java class Solution { public int[] searchRange(int[] nums, int target) { int[] arr = new int[]{-1, -1}; if(nums.length == 0 || nums == null) return arr; if (nums[0] > target || nums[nums.length - 1] < target) return arr; arr[0] = left(nums, target); if (arr[0] == -1) return arr; arr[1] = right(nums, target); return arr; } public int left(int[] nums, int target) { int l = 0; int r = nums.length - 1; int m = -1; while (l <= r) { m = l + (r - l) / 2; if (nums[m] >= target) r = m - 1; else if (nums[m] < target) l = m + 1; } if (nums[l] != target) return -1; return l; } public int right(int[] nums, int target) { int l = 0; int r = nums.length - 1; int m = -1; while (l <= r) { m = l + (r - l) / 2; if (nums[m] <= target) l = m + 1; else if (nums[m] > target) r = m - 1; } return r; } } ### 方法二：暴力法 超时！！！ 先找到第一个为目标值的位置，然后左右区域线性搜索 ### 代码 java class Solution { public int[] searchRange(int[] nums, int target) { int[] arr = new int[]{-1, -1}; if (nums.length == 0 || nums == null) return arr; for (int i = 0; i < nums.length; i++) { if (nums[i] == target) { if (i - 1 > -1 && nums[i - 1] != target || i - 1 == -1) arr[0] = i; if (i + 1 < nums.length && nums[i + 1] != target || i + 1 >= nums.length) arr[1] = i; } } return arr; } } 