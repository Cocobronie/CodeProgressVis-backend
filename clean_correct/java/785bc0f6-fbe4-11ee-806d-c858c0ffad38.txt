java private int left(int[] nums, int target) { int left = 0; int right = nums.length - 1; while (left <= right) { int mid = left + (right-left)/2; if (target == nums[mid]) { right = mid - 1; }else if (target < nums[mid]) { right = mid - 1; }else if (target > nums[mid]) { left = mid + 1; } } if (left == nums.length || nums[left] != target) { return -1; } return left; } **问题一**：在查找元素在排序数组中的第一个位置时，如果元素存在，那么最后是返回left还是right呢？ **返回left。** 由于是在闭区间[left,right]中查找第一个位置，那么当target==nums[mid]时，这时找到的可能就是第一个元素。但是，为了确认左半部分还有没有该元素，会将right的值设置为mid-1，此时由于数组是升序排列的，那么当左半部分查找不到该元素时，left最终的值就会是之前mid的值。 比如，在数组{5, 7, 8, 9, 10, 11} 中查找目标元素target=8。初始left=0，right=5，mid=2。这时target=8等于nums[mid]=8。 ![LeetCode34.002.jpeg](https: 接着，为了确认左半部分有没有元素8，会将right置位mid-1=1。 ![LeetCode34.003.jpeg](https: 这时区间[left,right]，即[0,1]内的元素是{5, 7}，此时mid=0，nums[mid]=5小于target=8。 ![LeetCode34.004.jpeg](https: 接着，left=mid+1=1。这时left=1，right=1，区间变为了[1,1]，区间内元素是{7}。 ![LeetCode34.005.jpeg](https: 这时mid=1。nums[mid]=7小于target=8。 ![LeetCode34.006.jpeg](https: 由于nums[mid]=7小于target=8，所以left=mid+1=2。这时left=2大于right=1，查找结束，而left指向的位置就是元素8出现的位置。 ![LeetCode34.007.jpeg](https: **问题二**：在查找元素在排序数组中的第一个位置时，怎么确定元素不存在呢？ **当要查找的元素大于排序数组中所有元素时** 比如，要在排序数组{5, 7, 7, 8, 8, 10}中查找目标元素target=15，这时target=15大于数组中所有的元素，那么查找结束时right=nums.length-1，left=nums.length，即left超出了数组nums的最大索引nums.lenght-1。由于上面已经确定最终返回left，因此在这种情况下元素不存在的条件是left==nums.length。 ![LeetCode34大于所有元素.mov](08a7d57e-e503-465f-b988-1a3ff9c7f13d) <br> **当要查找的元素小于排序数组中所有元素时** 比如，要在排序数组{5, 7, 7, 8, 8, 10}中查找目标元素target=-2，这时target=-2小于数组中所有的元素，那么查找结束时right=-1，left=0。这时元素不存在的条件是nums[left]!=target。 ![LeetCode34小于所有元素.mov](d000aff3-2fb1-434f-bc07-37e85b424c20) <br> **当要查找的元素大于排序数组中最小元素，小于排序数组中最大元素时** 比如，要在排序数组{5, 7, 7, 8, 8, 10}中查找目标元素target=9，这时target=9虽然在排序数组中不存在，但其大于数组中最小元素，小于数组中最大元素。因此，查找结束时left=5和right=4。也就是说在这种情况下，当目标元素在数组中不存在时，left的值是在区间[0，nums.lenght-1]内的。同样的，这时元素不存在的条件是nums[left]!=target。 根据上述分析，我们**确定了在左闭右闭的区间[left,right]内查找元素的第一个位置时，如果目标元素存在，则返回left；元素不存在的判断条件一是left==nums.length，二是nums[left]!=target。** ### 二、查找元素在排序数组中的最后一个位置 **代码实现** java private int right(int[] nums, int target) { int left = 0; int right = nums.length - 1; while (left <= right) { int mid = left + (right-left)/2; if (target == nums[mid]){ left = mid + 1; }else if (target < nums[mid]) { right = mid - 1; }else if (target > nums[mid]) { left = mid + 1; } } if (nums[right-1] != target) { return -1; } return right-1; } **问题一**：在查找元素在排序数组中的最后一个位置时，如果元素存在，那么最后是返回left还是right呢？ **返回right。** 由于是在闭区间[left,right]中查找最后一个位置，那么当target==nums[mid]时，这时找到的可能就是最后一个元素。但是，为了确认右半部分还有没有该元素，会将left的值设置为mid+1，此时由于数组是升序排列的，那么当右半部分查找不到该元素时，right最终的值就会是之前mid的值。 比如，在数组{5, 7, 8, 9, 10, 11} 中查找目标元素target=8。初始left=0，right=5，mid=2。这时target=8等于nums[mid]=8。 ![LeetCode34.009.jpeg](https: 接着，为了确认右半部分有没有元素8，会将left置位mid+1=3。 ![LeetCode34.010.jpeg](https: 这时区间[left,right]，即[3,5]内的元素是{9, 10, 11}，此时mid=4，nums[mid]=10大于target=8。 ![LeetCode34.011.jpeg](https: 接着right=mid-1=3。那么，这时left=3，right=3，区间变为了[3,3]，区间内元素是{9}。 ![LeetCode34.012.jpeg](https: 这时mid=3。nums[mid]=9大于target=8。 ![LeetCode34.013.jpeg](https: 由于nums[mid]=9大于target=8，因此right=mid-1=2。这时left=3大于right=2，查找结束，而right指向的位置就是元素8出现的位置。 ![LeetCode34.014.jpeg](https: **问题二**：在查找元素在排序数组中的最后一个位置时，怎么确定元素不存在呢？ **当要查找的元素大于排序数组中所有元素时** 比如，要在排序数组{5, 7, 7, 8, 8, 10}中查找目标元素target=15，这时target=15大于数组中所有的元素，那么查找结束时right=nums.length-1，left=nums.length。由于上面已经确定最终返回right，因此在这种情况下元素不存在的条件是nums[right]!=target。 ![LeetCode34大于所有元素.mov](aae604eb-28a7-4552-a8aa-86a0f5356c1f) <br> **当要查找的元素小于排序数组中所有元素时** 比如，要在排序数组{5, 7, 7, 8, 8, 10}中查找目标元素target=-2，这时target=-2小于数组中所有的元素，那么查找结束时right=-1，left=0。同样的，由于上面已经确定最终返回right，因此在这种情况下元素不存在的条件是right==-1。 ![LeetCode34小于所有元素.mov](1c049dee-e78b-47f6-b56c-285164af9e18) <br> **当要查找的元素大于排序数组中最小元素，小于排序数组中最大元素时** 比如，要在排序数组{5, 7, 7, 8, 8, 10}中查找目标元素target=9，这时target=9虽然在排序数组中不存在，但其大于数组中最小元素，小于数组中最大元素。因此，查找结束时left=5和right=4。也就是说在这种情况下，当目标元素在数组中不存在时，right的值是在区间[0，nums.lenght-1]内的。此时，元素不存在的条件是nums[right]!=target。 根据上述分析，我们确定了在左闭右闭的区间[left,right]内查找元素的最后一个位置时，如果目标元素存在，则返回right；元素不存在的判断条件一是right==-1，二是nums[right]!=target。 知道了如何查找第一个元素和最后一个元素的代码实现，对于该题目而言其代码实现就很容易了。这里不再赘述。 # 02 左闭右开区间[left,right) ### 一、查找元素在排序数组中的第一个位置 **代码实现** java private int left(int[] nums, int target) { int left = 0; int right = nums.length; while (left < right) { int mid = left + (right-left)/2; if (target == nums[mid]) { right = mid; }else if (target < nums[mid]) { right = mid; }else if (target > nums[mid]) { left = mid + 1; } } if (left == nums.length || nums[left] != target) { return -1; } return left; } **问题一**：在查找元素在排序数组中的第一个位置时，如果元素存在，那么最后是返回left还是right呢？ 由于在左闭右开区间[left,right)内查找目标值时，循环结束的条件是left==right，因此当目标值存在时，返回left和返回right是一样的。 **问题二**：在查找元素在排序数组中的第一个位置时，怎么确定元素不存在呢？ 目标元素在数组中不存在，一是目标元素大于数组中所有元素，这时，查找结束后，left=nums.lenght；二是目标元素小于数组中所有元素，这时查找结束后，left=0；三是目标元素大于数组中最小元素，小于数组中最大元素，这时，查找结束后，left肯定在区间[0,nums.length-1]内。 因此对于第一种情况，left==nums.length时，表示元素不存在；对于二、三这两种情况而言，当nums[left]!=target时，表示元素不存在。 需要注意的一点是当数组为空时，left和nums.lngth也是相等的，都等于0。 ### 二、查找元素在排序数组中的最后一个位置 **代码实现** java private int right(int[] nums, int target) { int left = 0; int right = nums.length; while (left < right) { int mid = left + (right-left)/2; if (target == nums[mid]){ left = mid + 1; }else if (target < nums[mid]) { right = mid; }else if (target > nums[mid]) { left = mid + 1; } } if (right ==0 || nums[right-1] != target) { return -1; } return right-1; } 