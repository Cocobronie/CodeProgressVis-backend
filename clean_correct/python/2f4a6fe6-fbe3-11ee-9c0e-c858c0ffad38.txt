python def naive(a, t): indices = [i for i, v in enumerate(a) if v == t] return [indices[0], indices[-1]] if indices else [-1, -1] python def single_bin_search(a, t): if not a: return [-1, -1] l, r = 0, len(a) - 1 while l < r: mid = (l + r) >> 1 if a[mid] < t: l = mid + 1 else: r = mid if a[l] != t: return [-1, -1] while l > 1: if a[l - 1] == t: l -= 1 else: break while r < len(a)-1: if a[r + 1] == t: r += 1 else: break return [l, r] python def double_bin_search(a, t): L, R = -1, -1 if not a: return [L, R] l, r = 0, len(a) - 1 while l < r: mid = (l + r) >> 1 if a[mid] < t: l = mid + 1 else: r = mid if a[l] != t: return [-1, -1] L = l r = len(a) - 1 while l < r: mid = (l + r + 1) >> 1 if a[mid] > t: r = mid - 1 else: l = mid R = r return [L, R] python class Solution: def searchRange(self, nums: List[int], target: int) -> List[int]: return double_bin_search(nums, target) 