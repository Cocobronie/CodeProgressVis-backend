cpp vector<int> searchRange(vector<int>& nums, int target) { vector<int> ret(2, -1); int n = nums.size(); bool hasFind = false; for (int i = 0; i < n; i++) { if (nums[i] == target && !hasFind) { ret[0] = i; hasFind = true; } if (nums[i] != target && hasFind) { ret[1] = i - 1; return ret; } } if (ret[0] != -1 && ret[1] == -1) ret[1] = n - 1; return ret; } 解法二：二分查找。 cpp class Solution { public: vector<int> searchRange(vector<int>& nums, int target) { vector<int> ret(2, -1); int n = nums.size(); if (n == 0) return ret; int left = 0; int right = n - 1; int mid; while (left < right) { mid = (left + right) / 2; if (nums[mid] < target) left = mid + 1; else right = mid; } if (nums[left] != target) return ret; ret[0] = left; left = 0; right = n - 1; while (left < right) { mid = (left + right + 1) / 2; if (nums[mid] <= target) left = mid; else right = mid - 1; } ret[1] = left; return ret; } }; ### 二分查找模板 模板一：根据 mid 值，选取 [left,mid] 或 [mid + 1,right] 。使用此模板，即 mid 只能与 left 分在一起。 cpp while (left < right) { mid = (left + right) / 2; if ... right = mid; else left = mid + 1; } 模板二：根据 mid 值，选取 [left,mid - 1] 或 [mid,right] 。使用此模板，即 mid 只能与 right 分在一起。 cpp while (left < right) { mid = (left + right + 1) / 2; if ... right = mid - 1; else left = mid; } 